<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>读导师论文的笔记 | pxd's blog</title><meta name="author" content="Paradox"><meta name="copyright" content="Paradox"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Online Scheduling of Heterogeneous Distributed Machine Learning Jobs总结  主题：分布式机器学习任务中的在线调度问题   问题:  考虑到需求弹性，在资源有限的情况下，如何确定分配给每个作业的worker和ps的数量、类型以及运行时间，从而最大限度地利用资源，最小化平均加权完成时间?  方法（解决步骤）： 1、先将平均加权完成时间">
<meta property="og:type" content="article">
<meta property="og:title" content="读导师论文的笔记">
<meta property="og:url" content="http://example.com/2024/06/25/%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="pxd&#39;s blog">
<meta property="og:description" content="Online Scheduling of Heterogeneous Distributed Machine Learning Jobs总结  主题：分布式机器学习任务中的在线调度问题   问题:  考虑到需求弹性，在资源有限的情况下，如何确定分配给每个作业的worker和ps的数量、类型以及运行时间，从而最大限度地利用资源，最小化平均加权完成时间?  方法（解决步骤）： 1、先将平均加权完成时间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.jpg">
<meta property="article:published_time" content="2024-06-25T04:15:33.000Z">
<meta property="article:modified_time" content="2024-06-25T16:28:46.612Z">
<meta property="article:author" content="Paradox">
<meta property="article:tag" content="Research">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/06/25/%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '读导师论文的笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-06-26 00:28:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="pxd's blog" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="pxd's blog"><span class="site-name">pxd's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">读导师论文的笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-25T04:15:33.000Z" title="发表于 2024-06-25 12:15:33">2024-06-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-25T16:28:46.612Z" title="更新于 2024-06-26 00:28:46">2024-06-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="Online-Scheduling-of-Heterogeneous-Distributed-Machine-Learning-Jobs"><a href="#Online-Scheduling-of-Heterogeneous-Distributed-Machine-Learning-Jobs" class="headerlink" title="Online Scheduling of Heterogeneous Distributed Machine Learning Jobs"></a>Online Scheduling of Heterogeneous Distributed Machine Learning Jobs</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p> <strong>主题</strong>：分布式机器学习任务中的在线调度问题</p>
</li>
<li><p> <strong>问题</strong>:  考虑到需求弹性，在资源有限的情况下，如何确定分配给每个作业的worker和ps的数量、类型以及运行时间，从而最大限度地利用资源，<strong>最小化平均加权完成时间</strong>?</p>
</li>
<li><p><strong>方法（解决步骤）</strong>：</p>
<p>1、先将平均加权完成时间最小化问题表述为一个时间索引的数学程序（3.3系统建模）</p>
<p><strong>建模中遇到的问题（非传统约束）</strong>：非传统约束包括类型约束和非传统约束（集合类型和自然语言描述）约束。以下变量不适合线性约束，又无法被现有方法处理。</p>
<ul>
<li><p>类型约束：每个作业使用一种类型的处理器，即每个作业只能使用一种处理器来保证资源效率。</p>
</li>
<li><p>非传统约束：描述了作业、处理器之间的关系，如约束条件(2d)中描述了$q_j、y_{jhm}和s_{jhp}$之间的关系，这种关系难以用线性约束描述。</p>
</li>
<li><p>其他约束：还包括至少为每个机器学习作业分配一个处理器来维护其全局参数的约束，以及为每个作业分配足够数量的工人和时间段来完成数据集的训练的约束。</p>
<p><strong>如何优化：</strong></p>
</li>
<li><p>由于问题涉及到整数变量、非线性约束等挑战性因素，需要应用紧凑指数技术（第五章）等方法来重新构建问题，以便于求解</p>
</li>
</ul>
<p>2、<strong>需要决策的变量</strong>: 包括worker和ps的数量/类型，以及每个作业的执行窗口</p>
<p>3、设计算法</p>
<ul>
<li><p>提出了一个在线框架$A_{online}$，通过将整体时间跨度划分为几何长度递增的区间（通过$A_{dual}$计算𝛼），将在线优化问题转换为一系列批量调度问题。</p>
</li>
<li><p><strong>在指定时间段内调度权重最大的作业，等价于平均加权完成时间最小</strong>（不知道说的对不对），所以解决最大加权调度问题：在一个 ML 集群中，给定一个截止时间𝜏𝑖，一组任务集合𝐽𝑖和每个任务的权重，构造一个可行的调度，使在时间𝜏𝑖内完成的任务的总权重最大化</p>
</li>
<li><p>$A_{dual}$用来对偶近似算法找到一个超过最优的不可行解，其中算法的性能是由允许的不可行程度来衡量的。由于作业执行可以跨越多个区间，因此不可行解最终将变得可行。超优目标值有 助于约束平均加权完成时间，$A_{maxweight}$用来选择权重最大作业来运行</p>
</li>
<li><p>在某一时间点之前调度尽可能多的未调度作业？</p>
</li>
<li><p>最大加权调度问题包含了几个非传统的约束，涉及整型变量、非线性约束(2b) (2c)和关于变量乘法(2f)(2h)(7b)的约束，还有集合类型的约束，用于表示worker和ps的配置/放置，因此还需要转换（紧凑指数技术优化）。<strong>解决方法：</strong>将每个有效调度编码为一个变量，并将原始程序重新构建为整数线性规划（ILP），其中只包括传统的打包约束，但代价是引入指数数量的变量。</p>
</li>
<li><p><strong>如何决策：</strong>将对偶变量解释为单位资源价格，并根据资源消耗成本和其机器学习框架计算每个作业的最佳调度。<strong>如果作业的权重高于其估计的服务成本，则算法会安排该作业。</strong>原因：给定有限的资源，希望调度具有更大效用的作业。</p>
</li>
</ul>
</li>
</ul>
<p>  4.算法细节：</p>
<ul>
<li><p><strong>截止时间如何划分</strong></p>
<p>截止时间是通过将潜在完成时间的时间跨度划分为几何递增点来划分的。具体来说，设置 $τ_0 = 1$，$τ_i = 2^i-1$。在第 i 轮中，等待直到时间达到$ τ_i$，然后将到达时间在$ τ_i$ 之前的作业划分为集合$ J_i$。</p>
</li>
<li><p><strong>对偶近似算法</strong>：原始问题和对偶问题之间存在一种对应关系，通过对偶问题的求解可以获得原始问题的信息</p>
<ol>
<li><p>对偶：算法通过找到一个超优的不可行解来衡量算法的性能，即生成一个长度不超过 ατi 且总权重至少等于最优权重的调度。这种不可行解最终会在作业执行跨越多个时间段后变得可行，从而体现了对偶性质。</p>
</li>
<li><p>近似：算法利用 γ -近似算法来解决最大权重调度问题，即在给定截止时间和作业集合的情况下，尽可能多地安排作业以最大化总权重。通过近似算法，可以在保证性能的前提下生成有效的调度方案，从而体现了近似性质。</p>
</li>
</ol>
<p>因此，对偶近似算法在处理最大权重调度问题时同时具有对偶性和近似性，通过这两个方面的特性来保证算法的性能和有效性。</p>
</li>
<li><p><strong>超优的不可行解</strong>：</p>
<p>超优的不可行解指的是一个在不可行的情况下具有优越性能的解。</p>
<p>通过对偶近似算法，算法会生成一个长度不超过$ ατi$ 且总权重至少等于最优权重的调度方案。这个调度方案在生成时是不可行的，但通过作业执行跨越多个时间段后会变得可行（原始的不可行解可能在某个时间段无法满足所有作业的要求，但随着时间的推移和作业的执行，可能会出现新的资源或条件使得原本不可行的解变得可行）。因此，通过对偶近似算法生成的超优的不可行解来评估算法的性能和有效性。</p>
</li>
<li><p><strong>竞争比率</strong>（competitive ratio）指的是<strong>在线算法的性能与最优离线算法的性能之间的比率</strong>。<br>$4α-competitive $表示在线算法的性能是最优离线算法性能的4倍。$A_{maxweight}$在算法3中的近似比率是$ 2log λ$。这里的近似比率表示 $A_{maxweight}$算法的性能相对于最优解的性能的近似比率。在这种情况下，近似比率为$ 2 log λ$，表明 $A_{maxweight}$ 算法的性能接近最优解的两倍对数级别</p>
</li>
</ul>
<ul>
<li><p><strong>$A_{dual}$算法流程，如何衡量不可行程度</strong></p>
<ol>
<li>$A_{dual}$算法调用γ-近似算法$A_{maxweight}$进行α轮。在每一轮中，选择尚未在之前轮次中服务过的作业进行调度。</li>
<li>在第$ι（ι ∈ [α]）$轮中，从时间$(ι-1)τ_i + 1$到时间$ιτ_i$内调度Ji中未在之前轮次中服务过的作业。</li>
<li>在每轮中，γ-近似算法的输入是当前轮次尚未服务的作业集合。在第一轮中，根据公式$w(J_{i1}^{s}) \geq \frac{1}{\gamma} w(J^*_{i1})$ 选择作业进行调度。</li>
<li>对于后续轮次$（ι ≥ 2）$，考虑可以被最优解调度但在前几轮未被$A_{dual}$服务的作业，选择这些作业进行调度。</li>
<li>通过γ-近似算法的多轮调度，尽可能多地调度作业，以实现最大化总权重的目标。</li>
</ol>
</li>
<li><p><strong>α 的值用来计算在线算法 $A_{online}$的竞争比率/衡量不可行程度</strong><br>$ \alpha = \left\lfloor \log \frac{w(J) - \log w_{\text{min}}}{\log \gamma - \log(\gamma - 1)} \right\rfloor + 1 $<br>其中，$ w(J) = \sum_{j \in J} w_j $表示作业的总权重，$ w_{\text{min}} = \min_{j \in [J]} w_j $ 表示作业的最小权重，$\gamma$ 是算法 3 中$A_{maxweight}$ 的近似比率。</p>
<p>通过计算得到的 α 值，可以用来衡量在线算法 $A_{online}$ 的竞争比率，进而评估算法的性能优劣。</p>
</li>
</ul>
<ul>
<li><strong>$A_{maxweight}$如何选择权重最大作业？</strong>（第五节）</li>
</ul>
<h4 id="第四节"><a href="#第四节" class="headerlink" title="第四节"></a><strong>第四节</strong></h4><p>介绍在线调度框架$A_{online}$，它将时间跨度划分为ML作业组。使用对偶近似算法$ A_{dual} $来进行作业调度。</p>
<p>$ A_{dual} $原理如下：</p>
<ul>
<li><p>$ A_{dual} $算法基于一个 <strong>γ-近似算法</strong>，用于解决最大权重调度问题，即在截止时间之前尽可能安排尚未安排的作业。</p>
<ul>
<li>在算法中，通过调用 γ-近似算法 $ A_{maxweight} $来执行 α 轮。在第$ ι$ 轮（其中$ ι （iota）∈ [α]$）中，从时间$ (ι-1)τ_i + 1 $到时间$ ιτ_i $安排作业集合$ Ji$ \ $J^s_i$, 即第$ ι $轮中在$ Ji $中但在之前的轮次中尚未服务的作业。每一轮运行长度不超过$ ατ_i$的作业，从而满足各种作业长度的需要；</li>
</ul>
</li>
<li><p>$ A_{dual} $构建出一个所需的调度方案，其长度最多为$ ατ_i$，总权重至少等于相应最大权重调度问题的最优目标值。</p>
</li>
</ul>
<p>$ A_{dual} $用来确定运行多少轮$ A_{maxweight} $.</p>
<h5 id="近似比引出；先引出，证明存在近似比，后计算："><a href="#近似比引出；先引出，证明存在近似比，后计算：" class="headerlink" title="近似比引出；先引出，证明存在近似比，后计算："></a>近似比引出；先引出，证明存在近似比，后计算：</h5><p>公式3：$w(J_{i1}^{s}) \geq \frac{1}{\gamma} w(J^<em><em>{i1})$，也就是${\gamma}w(J</em>{i1}^{s})  \geq w(J^</em>_{i1}) $，</p>
<p>这个不等式的含义是在算法设计中，确保在第1轮中选择的作业集合 $J_{i1}^s$ 的总权重不小于最优解 $J^*_{i1}$ 的总权重的 $\frac{1}{\gamma}$ 倍。这有助于保证算法在每一轮迭代中能够接近最优解。</p>
<p>公式4：$w(J_{i\iota}^s) \geq \frac{1}{\gamma} (w(J^<em><em>{i1}) - \sum</em>{\iota’ = 1}^{\iota - 1} w(J_{i\iota’}^{s’} ) \geq \frac{1}{\gamma} (w(J^</em><em>{i1}) - \sum</em>{\iota’ = 1}^{\iota - 1} w(J_{i\iota’}^{s}) )$</p>
<p>这个公式的含义是在算法设计中，确保在第 $\iota$ &gt;2轮中选择的作业集合 $J_{i\iota}^s$ 的总权重不小于最优解 $J_{i1}^*$ 的总权重<strong>减去之前轮次已经选择的作业集合的总权重</strong>的 $\frac{1}{\gamma}$ 倍。这有助于保证算法在每一轮迭代中能够接近最优解，提高算法的性能和效率。</p>
<h5 id="证明-alpha-取值为什么保证至少完成了最优解："><a href="#证明-alpha-取值为什么保证至少完成了最优解：" class="headerlink" title="证明$\alpha$取值为什么保证至少完成了最优解："></a><strong>证明$\alpha$取值为什么保证至少完成了最优解</strong>：</h5><p>公式5：$∑<em>{ι′=1}^{ι} w(J</em>{i\iota}^s) \geq [1 - (1 - \frac{1}{\gamma})^{\iota}]w(J^*_{i1})$</p>
<p>含义是，对于 $\iota \in [\alpha]$，以下不等式成立：前 $\iota$ 轮选择的作业集合的总权重之和大于等于 $[1 - (1 - \frac{1}{\gamma})^{\iota}]$ 倍最优解 $J^*_{i1}$ 的权重。这个不等式通过归纳法证明，每轮选择的作业集合都能接近最优解。</p>
<p>证明过程，假设在第$\iota^* $轮实现了最优解，如何求出$\iota^* $，找出了$\iota^* $的上限（略）</p>
<p>$ \alpha = \left\lfloor \log \frac{w(J) - \log w_{\text{min}}}{\log \gamma - \log(\gamma - 1)} \right\rfloor + 1 $</p>
<p>其中，$𝑤(𝐽)$ 表示作业集合$ 𝐽$的<strong>总权重</strong>，因为$w(J^*<em>{i1})$未知，只能用作业集合总权重估计。$𝑤</em>{min}$表示作业的最小权重，$𝛾$ 是算法中的近似比率。</p>
<h4 id="第五节"><a href="#第五节" class="headerlink" title="第五节"></a>第五节</h4><p>竞争比率（competitive ratio）指的是<strong>在线算法的性能与最优离线算法的性能之间的比率</strong>。4α-competitive 表示在线算法的性能是最优离线算法性能的4倍。</p>
<p><strong>$A_{maxweight}$在算法3中的近似比率是 2log λ(某一轮完成的：最优的比例）。近似比率表示 $A_{maxweight}$算法的性能相对于最优解的性能的近似比率</strong>。近似比率为 2 log λ 表明 $A_{maxweight}$ 算法的性能接近最优解的两倍对数级别</p>
<h3 id="PPT学习"><a href="#PPT学习" class="headerlink" title="PPT学习"></a>PPT学习</h3><h5 id="线性规划方法"><a href="#线性规划方法" class="headerlink" title="线性规划方法"></a><strong>线性规划方法</strong></h5><p>介绍了线性规划方法，包括以下几种：</p>
<ol>
<li>单纯形法（Simplex method）：沿着多面体边界的顶点序列进行步行，每一步都会改进目标值。</li>
<li>内点法（Interior-point method）：在多面体内部行走，每一步朝着多面体中的新可行解前进，新解在多面体内部而不是靠近边界。</li>
<li>椭球法（Ellipsoid method）：通过解决可行性问题来解决优化问题，通过二分搜索将可行性多面体包围在一个椭球内，利用分离神经元验证可行性或将椭球分成两半并用较小的椭球包围可行半部分，当椭球足够小时声称不可行。</li>
</ol>
<h5 id="对偶"><a href="#对偶" class="headerlink" title="对偶"></a><strong>对偶</strong></h5><p>在二元线性规划中，对偶（dual）是指与原始线性规划问题相关的另一个线性规划问题。对偶问题的目标是通过最大化（或最小化）原始问题的对偶函数来解决原始问题。对偶问题的解可以提供原始问题的下界（对于最小化问题）或上界（对于最大化问题），并且在某些情况下，对偶问题的解与原始问题的解是等价的，即它们的最优值相等。</p>
<p>线性规划对偶性质是指在线性规划问题中，原始问题（primal）和对偶问题（dual）之间存在一种特殊的关系。具体性质包括：</p>
<ol>
<li>如果原始问题是可行的并且具有最优解，那么对偶问题也是可行的，并且它们的最优目标函数值必须相同。</li>
<li><strong>原始问题的每个可行解都为对偶问题提供一个上界，反之亦然。</strong></li>
</ol>
<p>如何使用线性规划对偶性质：</p>
<ol>
<li>确定原始问题的约束条件和目标函数。</li>
<li>根据原始问题的形式，<strong>应用线性规划对偶性质，将原始问题转换为对偶问题。</strong> （如何转换？</li>
<li>解决对偶问题，找到最优解。</li>
<li>验证对偶问题的最优解是否与原始问题的最优解相关联，并且它们的目标函数值相等。</li>
</ol>
<h5 id="二元线性规划"><a href="#二元线性规划" class="headerlink" title="二元线性规划"></a><strong>二元线性规划</strong></h5><p>在线性规划中，二元性通常指的是线性规划问题中的决策变量是二元变量，即只能取0或1的取值。这种特殊的线性规划问题称为二元线性规划（binary linear programming）。在二元线性规划中，决策变量的取值限定为二元值，通常用于描述一些具有离散选择性质的问题。例如，在作业调度中，某些决策可能是“选择”或“不选择”某个资源，这种情况下可以使用二元变量来建模。</p>
<p>二元线性规划在实际问题中有着广泛的应用，例如在资源分配、作业调度、网络优化等领域。通过将问题转化为二元线性规划模型，可以更好地描述问题的离散性质，并利用线性规划的优化方法来求解问题的最优解。二元性的引入使得问题的建模更加灵活，能够应对更多实际场景中的离散性要求。</p>
<h5 id="参数服务器（parameter-server，ps）"><a href="#参数服务器（parameter-server，ps）" class="headerlink" title="参数服务器（parameter server，ps）"></a><strong>参数服务器（parameter server，ps）</strong></h5><p>将模型参数集中存储在参数服务器上。每次计算节点需要更新参数时，只需要向参数服务器发送请求，参数服务器更新后再将新的参数返回给计算节点，避免了每个节点都需要复制参数的问题。</p>
<h5 id="P24-同步训练（synchronous-training）"><a href="#P24-同步训练（synchronous-training）" class="headerlink" title="P24 同步训练（synchronous training）"></a><strong>P24 同步训练（synchronous training）</strong></h5><p>同步训练（synchronous training）的过程可能涉及以下步骤和特点：</p>
<ol>
<li>部署大量并行工作器（workers）：为了训练一个大型模型，可能需要部署数百个并发工作器，以实现并行计算。</li>
<li>数据并行模型和模型并行模型：可能使用数据并行模型和模型并行模型来实现训练任务的并行化，从而提高训练效率。</li>
<li>每个工作器训练一个数据块：在同步训练过程中，每个工作器可能负责训练一个数据块，以确保任务的分配和处理的有效性。</li>
<li>确保作业 j 有足够的工作器和时间槽：为了保证同步训练的顺利进行，可能需要确保作业 j 能够获得足够数量的工作器和时间槽。</li>
</ol>
<p>通过这些步骤和特点，同步训练过程可以实现大规模模型的训练，并利用并行计算的优势提高训练效率。</p>
<h5 id="mini-batch"><a href="#mini-batch" class="headerlink" title="mini-batch"></a><strong>mini-batch</strong></h5><p>在机器学习中，mini-batch（小批量）是指将训练数据集划分为一小批一小批的数据样本进行训练的方法。具体来说，mini-batch是介于全批量（full-batch）和随机批量（stochastic batch）之间的一种训练方式。在mini-batch训练中，每次迭代时模型不会处理整个数据集，而是从数据集中随机选择一小部分数据进行训练。</p>
<h3 id="《DPS-边缘云网络中分布式机器学习作业的动态定价和调度》"><a href="#《DPS-边缘云网络中分布式机器学习作业的动态定价和调度》" class="headerlink" title="《DPS:边缘云网络中分布式机器学习作业的动态定价和调度》"></a>《DPS:边缘云网络中分布式机器学习作业的动态定价和调度》</h3><ul>
<li><p><strong>问题</strong>：ML用户使用简单的线性定价方法来估计所需资源的数量是不经济的，很有可能做出错误的估计。对需求的低估会降低训练进度，而过高的估计会导致资源利用效率低下。</p>
</li>
<li><p><strong>方法</strong>：研究了在边缘-云网络中针对分布式机器学习作业的动态定价和调度问题。提出了在线框架<strong>DPS（Dynamic Pricing and Scheduling）</strong>。DPS包括作业接纳控制、价格函数设计和调度协调器。通过理论分析证明了DPS具有多项式时间复杂度，并分析了其竞争比。此外，通过测试实验和大规模模拟验证了算法的实际性能。</p>
</li>
<li><p><strong>结论</strong>：作者证明了DPS能够生成一个可行的社会福利最大化问题的解，并且具有较高的竞争比。实验结果表明，相对于当今云系统中的基准算法，DPS可以有效地避免资源饥渴，在相同的资源下完成更多的作业。因此，DPS框架在边缘-云网络中的资源分配问题上表现出较好的效果，有望提高作业执行效率和社会效益。</p>
</li>
</ul>
<p><strong>云计算的拍卖</strong>过程通常涉及两种实体的互动：拍卖者（auctioneer）和出价者（bidder）。以下是一般云计算拍卖过程的概述：</p>
<ol>
<li><p><strong>用户提交出价</strong>：用户在拍卖开始时提交自己的出价，即对所需资源的价格或条件的申请。</p>
</li>
<li><p><strong>拍卖者确定资源分配和价格</strong>：拍卖者根据用户的出价和需求，制定资源分配和价格策略。在云计算中，拍卖者可以是云服务提供商或资源管理系统。</p>
</li>
<li><p><strong>计算支付金额</strong>：拍卖者根据资源分配和价格策略，计算每位用户需要支付的金额。这个过程通常考虑到用户的需求、市场供需情况和公平性等因素。</p>
</li>
<li><p><strong>资源分配</strong>：拍卖者根据用户的出价和支付金额，分配相应的资源，确保资源的有效利用和满足用户需求。</p>
</li>
<li><p><strong>交易完成</strong>：一旦资源分配和价格确定，交易即完成，用户可以开始使用所获得的资源进行计算、存储或其他云服务。</p>
</li>
</ol>
<h4 id="第二节"><a href="#第二节" class="headerlink" title="第二节"></a>第二节</h4><p>社会福利最大化问题（social welfare maximization problem）：资源有限的前提下，如何使各方需求得到最大满足。将社会福利最大化问题转化为混合整数非线性规划（MINLP）。这个问题涉及传统约束（资源容量约束）和非传统约束。</p>
<ul>
<li><strong>传统约束</strong>：传统约束指的是资源容量约束，即系统中可用资源的限制，例如工作者和参数服务器的数量、带宽等。</li>
<li><strong>非传统约束</strong>：非传统约束包括作业开始时间、作业完成时间和数据传输延迟等。这些约束反映了作业在边缘-云网络中执行时的实际情况和限制。</li>
</ul>
<p>社会福利最大化的公式如下：</p>
<p>$\operatorname{maximize} \sum_{j \in[J]} x_j f_j\left(\hat{t}_j-r_j\right)$</p>
<p>在该公式中，涉及以下几个要素的解释：</p>
<ul>
<li><p>∑$j \in[J]$：表示对所有作业j的求和，即考虑所有作业的社会福利总和。</p>
</li>
<li><p>$x_j$ ：表示作业j的决策变量，指示作业j是否被接受。</p>
</li>
<li><p>$f_j\left(\hat{t}_j-r_j\right)$：表示作业j的效用函数，其中$\hat{t}_j$表示作业j的完成时间，$r_j$表示作业j的到达时间。作业的效用函数考虑了作业的完成时间与到达时间之间的差异，以体现作业的效率和质量</p>
</li>
</ul>
<h4 id="第三节"><a href="#第三节" class="headerlink" title="第三节"></a>第三节</h4><p>对动态定价和在线调度的问题建模，具体内容如下：</p>
<ol>
<li><p><strong>系统设置介绍</strong>：第3.1节介绍了系统的设置，包括边缘-云网络中的边缘服务器、远程云、操作员、参数服务器和工作者等组成部分。这些组件共同构成了一个边缘-云系统，用于执行机器学习作业的动态定价和调度。</p>
</li>
<li><p><strong>拍卖设置和代理互动</strong>：第3.1节介绍了拍卖设置和代理之间的互动过程，包括接受或拒绝作业、调度已接受的作业、模拟和计算、提交作业竞标、更新参数等步骤。</p>
</li>
<li><p><strong>约束条件</strong>：第3.2节提出了基本的约束条件，包括作业的资源需求、作业的开始和结束时间、资源的供应和需求等</p>
</li>
</ol>
<ul>
<li><p>$[X]$: 整数集合 ${1, 2, \ldots, X}$</p>
</li>
<li><p>$J, S, T$: 作业数量、物理服务器数量和时间槽数量</p>
</li>
<li><p>$j, s, t$: 作业、物理服务器和时间槽的索引</p>
</li>
<li><p>$W, P$: 工作者和参数服务器类型的数量</p>
</li>
<li><p>$r_j$: 作业 $j$ 的到达时间</p>
</li>
<li><p>$f_j(\cdot)$: 作业 $j$ 的效用函数</p>
</li>
<li><p>$C_{sw}, C_{sp}$: 服务器 $s$ 上类型-$w$工作者和类型-$p$参数服务器的数量</p>
</li>
<li><p>$E_j, D_j, M_j$: 作业 $j$ 中训练轮数、数据块数量和每个数据块中的小批次数量</p>
</li>
<li><p>$\Delta^\uparrow_{js}$: 将作业 $j$ 的一个数据块传输到服务器 $s$ 的延迟时间</p>
</li>
<li><p>$b_w, b_p$: 类型-$w$工作者和类型-$p$参数服务器的带宽</p>
</li>
<li><p>$x_j$: 接受作业 $j$ 的决策变量</p>
</li>
<li><p>$o_{jw}, o_{jp}$: 作业 $j$ 是否使用类型-$w$工作者和类型-$p$参数服务器</p>
</li>
<li><p>$y_{jsw}(t)$: 服务器 $s$ 在时间 $t$ 分配给作业 $j$ 的类型-$w$工作者数量</p>
</li>
<li><p>$z_{jsp}(t)$: 服务器 $s$ 在时间 $t$ 分配给作业 $j$ 的类型-$p$参数服务器数量</p>
</li>
<li><p>$p_j$: 作业 $j$ 被接受时应支付的费用</p>
</li>
<li><p>$a_j, \hat{t}_j$: 作业 $j$ 的开始和完成时间</p>
</li>
<li><p>$\psi_j$: 作业 $j$ 的工作者和参数服务器是否放置在一起</p>
</li>
<li><p>$k_{wpj}$: 作业 $j$ 使用类型-$w$工作者和类型-$p$参数服务器训练一个小批次的时间</p>
</li>
</ul>
<h4 id="第四节-1"><a href="#第四节-1" class="headerlink" title="第四节"></a>第四节</h4><p>DPS（Dynamic Pricing and Scheduling）算法的设计主要包括以下几个步骤：</p>
<ol>
<li><p><strong>决策变量封装</strong>：首先，DPS将所有决策变量封装成一个新的变量，然后等价地将原始问题重新表述为一个打包问题。这个步骤有助于简化问题的复杂性，使得算法更易于实现和理解。</p>
</li>
<li><p><strong>对偶问题制定</strong>：DPS进一步制定了对原问题的对偶问题，并设计了拍卖接纳机制。通过对原问题和对偶问题的设计，DPS能够更好地实现社会福利的最大化。</p>
</li>
<li><p><strong>算法设计</strong>：DPS通过模拟每个作业的最佳调度来实现社会福利的最大化，采用了一些贪心的算法来计算最优的工作者和参数服务器的部署。主要包括以下几个关键组件：</p>
<ul>
<li><p><strong>作业接纳控制（Admission Control）</strong>：DPS算法首先通过作业接纳控制来决定是否接受一个新的作业。在接受作业时，需要考虑系统当前的资源状态、作业的资源需求以及系统的负载情况等因素。作业接纳控制的目标是最大化社会福利，并确保系统资源的有效利用。</p>
</li>
<li><p><strong>价格函数设计（Price Function Design）</strong>：DPS算法设计了合适的价格函数，用于确定工作者和参数服务器的价格。价格函数的设计需要考虑作业的特性、资源的供需关系以及系统的整体收益等因素。通过合理设计价格函数，DPS能够实现资源的动态定价，以最大化社会福利。</p>
</li>
<li><p><strong>调度协调器（Scheduling Policy Orchestrator）</strong>：DPS算法的调度协调器负责协调和调度已接受的作业，以实现社会福利的最大化。调度协调器需要考虑作业的执行顺序、资源分配方案以及作业的完成时间等因素，以确保系统资源的有效利用和作业的高效执行。</p>
</li>
</ul>
</li>
</ol>
<h4 id="第五节、第六节"><a href="#第五节、第六节" class="headerlink" title="第五节、第六节"></a>第五节、第六节</h4><p>第五节和第六节中主要进行了实现和评估的工作，包括以下内容：</p>
<ol>
<li><p><strong>实现测试平台</strong>：基于MXNet框架构建了一个测试平台，用于实现DPS作为调度器。该测试平台还包括了Hadoop分布式文件系统（HDFS）等组件，用于支持作业的动态部署和参数的存储。</p>
</li>
<li><p><strong>实验评估</strong>：进行了大规模的模拟实验，通过与基准算法（如FIFO和DRF）的比较，评估了DPS算法的性能表现。实验结果表明，DPS在处理作业数量方面表现最优，能够避免资源匮乏现象，并且相较于基准算法，DPS能够实现更多的作业完成，提高社会福利。</p>
</li>
<li><p><strong>结果分析</strong>：通过实验结果分析，验证了DPS算法相对于基准算法的优势，证明了DPS在边缘-云网络中资源分配和作业调度方面的有效性和性能优势。实验结果进一步支持了DPS算法在实际应用中的可行性和有效性。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Paradox</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/06/25/%E7%AC%94%E8%AE%B0/">http://example.com/2024/06/25/%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">pxd's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Research/">Research</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2021/01/23/first/" title="第一篇博文"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第一篇博文</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Paradox</div><div class="author-info__description">Keep learning!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Hello-day"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Online-Scheduling-of-Heterogeneous-Distributed-Machine-Learning-Jobs"><span class="toc-number">1.</span> <span class="toc-text">Online Scheduling of Heterogeneous Distributed Machine Learning Jobs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82"><span class="toc-number">1.2.</span> <span class="toc-text">第四节</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%91%E4%BC%BC%E6%AF%94%E5%BC%95%E5%87%BA%EF%BC%9B%E5%85%88%E5%BC%95%E5%87%BA%EF%BC%8C%E8%AF%81%E6%98%8E%E5%AD%98%E5%9C%A8%E8%BF%91%E4%BC%BC%E6%AF%94%EF%BC%8C%E5%90%8E%E8%AE%A1%E7%AE%97%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">近似比引出；先引出，证明存在近似比，后计算：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%81%E6%98%8E-alpha-%E5%8F%96%E5%80%BC%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81%E8%87%B3%E5%B0%91%E5%AE%8C%E6%88%90%E4%BA%86%E6%9C%80%E4%BC%98%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">证明$\alpha$取值为什么保证至少完成了最优解：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82"><span class="toc-number">1.3.</span> <span class="toc-text">第五节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PPT%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">PPT学习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.1.</span> <span class="toc-text">线性规划方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E5%81%B6"><span class="toc-number">2.0.2.</span> <span class="toc-text">对偶</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="toc-number">2.0.3.</span> <span class="toc-text">二元线性规划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%88parameter-server%EF%BC%8Cps%EF%BC%89"><span class="toc-number">2.0.4.</span> <span class="toc-text">参数服务器（parameter server，ps）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#P24-%E5%90%8C%E6%AD%A5%E8%AE%AD%E7%BB%83%EF%BC%88synchronous-training%EF%BC%89"><span class="toc-number">2.0.5.</span> <span class="toc-text">P24 同步训练（synchronous training）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mini-batch"><span class="toc-number">2.0.6.</span> <span class="toc-text">mini-batch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%8ADPS-%E8%BE%B9%E7%BC%98%E4%BA%91%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%8A%A8%E6%80%81%E5%AE%9A%E4%BB%B7%E5%92%8C%E8%B0%83%E5%BA%A6%E3%80%8B"><span class="toc-number">3.</span> <span class="toc-text">《DPS:边缘云网络中分布式机器学习作业的动态定价和调度》</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8A%82"><span class="toc-number">3.1.</span> <span class="toc-text">第二节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82"><span class="toc-number">3.2.</span> <span class="toc-text">第三节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-1"><span class="toc-number">3.3.</span> <span class="toc-text">第四节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82%E3%80%81%E7%AC%AC%E5%85%AD%E8%8A%82"><span class="toc-number">3.4.</span> <span class="toc-text">第五节、第六节</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/25/%E7%AC%94%E8%AE%B0/" title="读导师论文的笔记">读导师论文的笔记</a><time datetime="2024-06-25T04:15:33.000Z" title="发表于 2024-06-25 12:15:33">2024-06-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/01/23/first/" title="第一篇博文">第一篇博文</a><time datetime="2021-01-23T07:39:26.000Z" title="发表于 2021-01-23 15:39:26">2021-01-23</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Paradox</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  let initFn = window.walineFn || null

  const initWaline = (Fn) => {
    const waline = Fn(Object.assign({
      el: '#waline-wrap',
      serverURL: 'waline-server-kohl-mu.vercel.app# Waline server address url',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))

    const destroyWaline = () => {
      waline.destroy()
    }

    btf.addGlobalFn('pjax', destroyWaline, 'destroyWaline')
  }

  const loadWaline = async () => {
    if (initFn) initWaline(initFn)
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.css')
      const { init } = await import('https://cdn.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline.min.js')
      initFn = init || Waline.init
      initWaline(initFn)
      window.walineFn = initFn
    }
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>